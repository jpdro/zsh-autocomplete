#!/bin/zsh

.autocomplete.async-completion.precmd() {
  emulate -L zsh -o extendedglob -o NO_shortloops -o warncreateglobal
  add-zsh-hook -d precmd .autocomplete.async-completion.precmd

  [[ -v _AUTOCOMPLETE__ASYNC_DELAY ]] || typeset -gHF _AUTOCOMPLETE__ASYNC_DELAY=.75
  [[ -v _AUTOCOMPLETE__ASYNC_TIMEOUT ]] || typeset -gHF _AUTOCOMPLETE__ASYNC_TIMEOUT=1.5

  typeset -gH _autocomplete__buffer _autocomplete__word

  typeset -gHi _autocomplete__async_completion_fd _autocomplete__async_completion_pid
  zle -N .autocomplete.async-completion.list-choices

  typeset -gHi _autocomplete__async_timeout_fd _autocomplete__async_timeout_pid
  zle -N .autocomplete.async-completion.timeout

  zle -C _list_choices list-choices _autocomplete.async-completion.list-choices
  zle -C _explain list-choices _autocomplete.async-completion.explain

  autoload -Uz add-zle-hook-widget
  add-zle-hook-widget -d line-pre-redraw .autocomplete.async-completion.start
  add-zle-hook-widget line-pre-redraw .autocomplete.async-completion.start

  add-zsh-hook -d preexec .autocomplete.async-completion.stop
  add-zsh-hook preexec .autocomplete.async-completion.stop
  add-zsh-hook -d zshexit .autocomplete.async-completion.stop
  add-zsh-hook zshexit .autocomplete.async-completion.stop
}

.autocomplete.async-completion.stop() {
  emulate -L zsh -o extendedglob -o NO_shortloops -o warncreateglobal

  .autocomplete.kill $_autocomplete__async_completion_fd $_autocomplete__async_completion_pid
  _autocomplete__async_completion_fd=0
  _autocomplete__async_completion_pid=0

  .autocomplete.kill $_autocomplete__async_timeout_fd $_autocomplete__async_timeout_pid
  _autocomplete__async_timeout_fd=0
  _autocomplete__async_timeout_pid=0

  _autocomplete__buffer=''
  _autocomplete__word=''
}

.autocomplete.async-completion.start() {
  setopt $_autocomplete__options

  if (( KEYS_QUEUED_COUNT + PENDING > 0 )) || [[ -z $BUFFER ]]; then
    _autocomplete__buffer=''
    _autocomplete__word=''
    return 0
  fi

  typeset -F SECONDS=0.0

  .autocomplete.kill $_autocomplete__async_completion_fd $_autocomplete__async_completion_pid
  exec {_autocomplete__async_completion_fd}< <(
    local pid=$sysparams[pid]
    print -r $pid

    [[ -v functions[_zsh_autosuggest_disable] ]] && _zsh_autosuggest_disable
    {
      local REPLY
      zpty _autocomplete__zpty .autocomplete.async-completion.pty '$LBUFFER' '$RBUFFER'
      zpty -w _autocomplete__zpty $'\t'

      local line
      zpty -r _autocomplete__zpty line '*'$'\0'$'\0'
      zpty -r _autocomplete__zpty line '*'$'\0'$'\0'
      print -r $pid$'\0'$SECONDS$'\0'$line
    } always {
      zpty -d _autocomplete__zpty
      kill -TERM $pid
    }
  )
  read _autocomplete__async_completion_pid <&$_autocomplete__async_completion_fd
  zle -Fw "$_autocomplete__async_completion_fd" .autocomplete.async-completion.list-choices

  .autocomplete.kill $_autocomplete__async_timeout_fd $_autocomplete__async_timeout_pid
  exec {_autocomplete__async_timeout_fd}< <(
    {
      local pid=$sysparams[pid]
      print -r $pid

      setopt NO_xtrace NO_verbose
      [[ -v functions[_zsh_autosuggest_disable] ]] && _zsh_autosuggest_disable

      local complete_pid=$_autocomplete__async_completion_pid
      local complete_fd=$_autocomplete__async_completion_fd

      sleep $(( _AUTOCOMPLETE__ASYNC_TIMEOUT - SECONDS ))

      print -r $pid$'\0'$complete_fd$'\0'$complete_pid$'\0'$'\0'
    } always {
      kill -TERM $pid
    }
  )
  read _autocomplete__async_timeout_pid <&$_autocomplete__async_timeout_fd
  zle -Fw "$_autocomplete__async_timeout_fd" .autocomplete.async-completion.timeout

  # There's a weird bug in Zsh < 5.8, where where ^C stops working unless we force a fork.
  # See https://github.com/zsh-users/zsh-autosuggestions/issues/364
  command true
}

.autocomplete.async-completion.pty() {
  setopt $_autocomplete__options
  setopt NO_xtrace NO_verbose NO_banghist

  local hooks=( chpwd periodic precmd preexec zshaddhistory zshexit zsh_directory_name )
  unset ${^hooks}_functions &> /dev/null
  unfunction $hooks &> /dev/null
  hooks=( isearch-exit isearch-update line-pre-redraw
    line-init line-finish history-line-set keymap-select )
  zle -D zle-$^hooks &> /dev/null

  typeset -gH lbuffer=$1 rbuffer=$2

  zle-widget() {
    LBUFFER=$lbuffer
    RBUFFER=$rbuffer

    zle completion-widget 2> /dev/null
  }

  post() {
    typeset -gH message=$msg
    compstate[list]=''
    compstate[list_max]=0
  }

  completion-widget() {
    unset 'compstate[vared]'

    local +h -a comppostfuncs=( post )
    _main_complete &> /dev/null
    compstate[insert]=''

    local -i nm=$compstate[nmatches] ll=$compstate[list_lines]
    print -r $'\0'$'\0'$nm$'\0'$ll$'\0'$BUFFER$'\0'${words[CURRENT]}$'\0'$message$'\0'$'\0'
  }

  zle -N zle-widget
  zle -C completion-widget list-choices completion-widget
  bindkey '^I' zle-widget
  vared LBUFFER 2>&1
}

.autocomplete.async-completion.list-choices() {
  setopt $_autocomplete__options

  local -F seconds
  local -i pid nmatches list_lines
  local buffer word msg eof
  {
    [[ -z $2 || $2 == hup ]] &&
      IFS=$'\0' read -r -u "$1" pid seconds nmatches list_lines buffer word msg eof
  } always {
    .autocomplete.kill $1 $pid
    if [[ $1 == $_autocomplete__async_completion_fd &&
        $pid == $_autocomplete__async_completion_pid ]]; then
      _autocomplete__async_completion_fd=0
      _autocomplete__async_completion_pid=0
    fi
  }

  # If a widget can't be called, ZLE always returns true.
  # Thus, we return false on purpose, so we can check if our widget got called.
  setopt NO_banghist NO_warncreateglobal
  if ! zle _list_choices -w -- $seconds $nmatches $list_lines $msg
  # 2> /dev/null ;
  then
    # Refresh if and only if our widget got called. Otherwise, ZLE will crash (eventually).
    .autocomplete.highlight
    zle -R

    _autocomplete__buffer=$buffer
    _autocomplete__word=$word
  fi
}

_autocomplete.async-completion.list-choices() {
  local -F seconds=$1
  local -i nmatches=$2 list_lines=$3
  local msg=$4 reply

  if () {
    local min_input; zstyle -s ":autocomplete:$curcontext" min-input min_input || min_input=1
    [[ $compstate[context] == command && $curcontext != history-*search*:* ]] &&
      (( CURRENT == 1 && $#words[CURRENT] < min_input ))
  }; then
    return 2
  fi

  (( seconds > _AUTOCOMPLETE__ASYNC_DELAY )) && zle -Rc "processing…"

  if (( nmatches == 0 )); then
    eval "$_comp_setup"
    if [[ -n $msg ]]; then
      _autocomplete.explanation info $msg
    else
      zstyle -s ":autocomplete:${curcontext}:no-matches-at-all" message msg ||
        msg='No matching completions found.'
      _autocomplete.explanation error $msg
    fi
  elif () {
    local max_lines; zstyle -s ":autocomplete:$curcontext" max-lines max_lines || max_lines='50%'
    (( list_lines > _autocomplete__max_lines($max_lines) ))
  }; then
    eval "$_comp_setup"
    zstyle -s ":autocomplete:${curcontext}:too-many-matches" message msg ||
      msg="Too long list. Press ↓ or ⇟ to open; type more to filter."
    _autocomplete.explanation info $msg
  else
    local +h -a comppostfuncs=(
      _autocomplete.async-completion.list-choices.post $comppostfuncs[@] )
    _main_complete
  fi

  compstate[insert]=''
  compstate[list]='list force'

  # If a widget can't be called, ZLE always returns 0.
  # Thus, we return non-0 on purpose, so we can check if our widget got called.
  return 2
}

_autocomplete.async-completion.list-choices.post() {
  compstate[insert]="$_lastcomp[insert]"
}

.autocomplete.async-completion.timeout() {
  setopt $_autocomplete__options

  local -i pid complete_fd complete_pid
  local eof
  {
    [[ -z $2 || $2 == hup ]] && IFS=$'\0' read -r -u "$1" pid complete_fd complete_pid eof
  } always {
    .autocomplete.kill $1 $pid
  }

  [[ $complete_fd == $_autocomplete__async_completion_fd &&
      $complete_pid == $_autocomplete__async_completion_pid ]] || return

  .autocomplete.kill $complete_fd $complete_pid

  [[ -z $BUFFER ]] && return

  _autocomplete__buffer=''
  _autocomplete__word=''

  # If a widget can't be called, ZLE always returns 0.
  # Thus, we return non-0 on purpose, so we can check if our widget got called.
  setopt NO_banghist NO_warncreateglobal
  if ! zle _explain error 'Completion timed out.' 2> /dev/null; then
    # Refresh if and only if our widget got called. Otherwise, ZLE will crash (eventually).
    .autocomplete.highlight
    zle -R
  fi
}

_autocomplete.async-completion.explain() {
  eval "$_comp_setup"

  _autocomplete.explanation $1 $2
  buffer=$BUFFER
  word=$words[CURRENT]
  compstate[list]='list force'
  return 1
}

emulate -L zsh -o extendedglob -o NO_shortloops -o warncreateglobal

zmodload zsh/system zsh/zpty
autoload -Uz .autocomplete.kill

add-zsh-hook precmd .autocomplete.async-completion.precmd
